# 数组
---
- 数组大小固定 -> 运行时性能较好
- 不能随意向数组中增加元素
- 如果不清楚元素的确切个数,请使用vector

> 和内置类型的变量一样,如果在函数内部定义了某种内置类型的数组,那么默认初始化会另数组含有未
定义的值.

字符数组需要有显示空字符,例如:
```
char a2[] = {'C','+',"+",'\0'};//含有显式空字符
char a3[] = "C++";//自动添加空字符
const char a4[6] = "Daniel";//错误,大小应该是7,要留出显示空字符的位置.
```

不允许拷贝和复制(考虑`=`初始化的定义)
```
int a[] = {0,1,2};
int a2[] = a;// 不允许使用一个数组初始化另一个
a2 = a;// 不允许把一个数组直接赋值给另一个
```

类型修饰符从右向左依次绑定.
就数组而言,修饰符从内向外.

> 要想理解数组声明的含义,最好的办法是从数组名字开始,按照由内向外的顺序阅读.

> 大多数常见的安全问题都源于缓冲区溢出错误.当数组或其他类似数据结构的下标越界并试图访问非法
内存区域时,就会产生此类错误.

在很多用到数组名字的地方,编译器都会自动地将其替换为一个指向数组首元素的指针.由此,在一些情况
下数组的操作实际上是指针的操作.比如,当使用数组做为一个auto变量的初始值时,推断得到的类型是
指针而非数组.当使用decltype关键字时,返回的类型是数组.

> 在大多数表达式中,使用数组类型的对象其实是使用一个指向该数组首元素的指针.

> 一个指针如果指向了某种内置内心数组的尾元素的"下一位置",则其具备与vector和end函数返回的
与迭代器类似的功能.特别要注意,尾后指针不能执行解引用和递增操作.

只要两个指针指向同一个数组元素,或者指向该数组尾元素的下一位置,就能利用关系运算符对其进行比较.
如果两个指针分别指向不相关的对象,则不能比较它们.

> 内置的下标运算符所用的索引值不是无符号类型,这一点与vector和string不一样.

> 对于大多数应用来说,使用标准库string要比使用C风格字符串更安全,更高效.

不允许使用一个数组为另一个内置类型的数组赋初值,也不允许使用vector对象初始化数组,相反,允许
使用数组来初始化vector对象.

> 建议:尽量使用标准库类型而非数组
使用指针和数组很容易出错.现代的C++程序应当尽量使用vector和迭代器,避免使用内置数组和指针;应该
尽量使用string,避免使用C风格的基于数组的字符串.

严格来说C++语言中没有多维数组,通常所说的多维数组其实是数组的数组.谨记这一点,对今后理解和使用
多维数组大有益处.

要使用范围for语句处理多维数组,除了最内层的循环外,其他所有循环的控制变量都应该是引用类型.


美队3
