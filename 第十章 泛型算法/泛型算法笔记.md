# 泛型算法
---
第10章里的泛型算法可以慢慢读,读完以后可以写出高逼格的函数式风格C++.
---
标准库容器定义的操作集合惊人的小.标准库并未给每个容器添加大量功能,而是提供了一组算法,这些算法
大多独立于任何特定容器.这些算法是通用的:他们可用于不同类型的容器和不同类型的元素.
---

泛型(通用)算法:
- 算法:实现了经典算法的公共接口
- 泛型: 可用于不同类型的容器和元素

---

关键概念:算法永远不会执行容器的操作.
  泛型算法本身不会执行容器的操作,它们只会运行于迭代器之上,执行迭代器的操作.该特性带来一个
令人惊讶但非常必要的编程假定:算法永远不会改变底层容器的大小.算法可能改变容器中保存的元素的
值,也可能在容器内移动元素,但永远不会直接添加或删除元素.

>`BestPractise`:对于只读取而不改变元素的算法,通常最好使用`cbegin()`和`cend()`.但是,如果
你计划使用算法返回的迭代器来改变元素的值,就需要使用`begin()`和`end()`的结果作为参数.


---
一个初学者,非常容易犯的错误是在一个空容器上调用fill_n(或类似的写元素的算法).我们指定了要写
入10个元素,但容器是空的,得到结果是未定义的.

谓词:谓词是一个可调用的表达式,其返回结果是一个能用做条件的值.标准库算法所使用的谓词分为两类:
一元谓词(意味着它们只接受单一参数)和二元谓词(意味着有两个参数).接受谓词参数的算法对输入序列
中的元素调用谓词.因此,元素类型必须能转换为谓词的参数类型.


---
我们希望对算法进行更多参数的操作,衍生出Lambda表达式.一个Lambda表达式表示一个可调用代码单元,
它可以定义在函数的内部.表达式形式:`f= [捕获列表](参数列表){函数体}`,参数列表为空时,()可以省略.

如果未指定返回内容,则Lambda返回void

Lambda只有在捕获列表中捕获一个它所在函数的局部变量,才能在函数体中使用该变量,Lambda可以直接
使用定义在函数之外的名字或者局部static变量.
