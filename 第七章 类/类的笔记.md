# 类
---
this形参是隐式定义的.
this总是执行"这个"对象,因此this是一个常量指针.
默认情况下,this的类型是指向类类型非常量版本的常量指针.
不能把this绑定到一个常量上,他是一个常量指针,但不指向常量.

一般来说,当我们定义的函数类似于某个内置运算符时,应该令函数的行为尽量模仿这个运算符.

默认构造函数
合成的默认构造函数.
---
```
Sales_data() = default;
Sales_data(const std::string &s) : bookNo(s){}
Sales_data(const std::string &s,unsigned n,double p):bookNo(s),units_sold(n),revenue(p*n){}
Sales_data(std::istream &);
```
Salese_data() = default;因为该构造函数不接受任何实参,所以它是一个默认构造参数.我们希望这
个函数的作用完全等同于之前使用的合成默认构造函数.

在C++11新标准中,如果我们需要默认的行为,那么可以通过在参数列表后面写上`=default`来要求编译器
生成构造函数.

Sales_data(const std::string &s) : bookNo(s){}.
构造函数初始值列表,负责为新创建的对象的一个或几个数据成员赋初值.
构造函数初始值是成员名字的一个列表,每个名字后面紧跟括号括起来的成员初始值.不同成员之间以逗号分隔.

如果有的成员显式初始化,有的没有,则没有显式初始化的成员,将以合成默认构造器函数相同的方式隐式
初始化.

>`BestPractise`:构造函数不应该轻易覆盖掉类内的初始值,除非新赋的值与原值不同.如果你不能使用
类内初始值,则所有构造函数都应该显式地初始化每个内置类型的成员.

注意:这些构造函数的函数体都是空的,因为这些构造函数的唯一目的就是为数据成员赋初值,一旦没有
其他任务需要执行,函数体也就为空了.

Sales_data(std::istream &);以istream为参数的构造函数需要执行一些实际的操作.
```
Sales_data::Sales_data(std::istream &is)
{
  // 从is中读取信息,写入this对象
  read(is, *this);
}
```
本函数没有构造函数初值列表,准确的讲,构造函数初值列表为空.但是由于执行了构造函数体,对象的成员
仍然能够初始化.

---
一个类可以包含0个或多个访问说明符,而且对于某个访问说明符能出现多少次也没严格限定.每个访问说明符
指定了接下来的成员的访问级别,其有效范围直到出现下一个访问说明符或者到达类的结尾处为止.
---
类可以允许其他类或者函数访问它的非公有成员,方法是另其他类或者函数成为它的友元.需要在函数声明
开始处增加friend.
友元不是类的成员,也不受它所在区域访问控制级别的约束.一般来说,最好在类定义开始或结束前的位置集中
声明友元.
优点:
    可以灵活地实现需要访问若干类的私有或受保护成员才能完成的任务,便于与其他不支持类的语言进行混合编程
缺点:
    破坏了类的封装性,降低该类的可靠性.

---
如果一个类指定了友元类,则友元类的成员函数可以访问此类包括非公有成员在内的所有成员.

友元关系不存在传递性,友元的友元,不是我的友元.(我附庸的附庸,不是我的附庸.)

每个类负责控制自己的友元类或友元函数.

---
编译器处理完类中的全部声明后才会处理成员函数的定义.

名字查找的顺序:由内而外,自上而下.
---
如果成员是const,引用,或者属于某种未提供默认构造函数的类类型,我们必须通过构造函数初始值列表为这些成员提供初值.

建议:使用构造函数初始值.
在很多类中,初始化和赋值的区别事关底层效率问题:前者直接初始化数据成员,后者先初始化再赋值.
除了效率问题外更重要的是,一些数据成员必须被初始化.建议读者养成使用构造函数初始值的习惯,这样
能避免某些意想不到的编译错误,特别是遇到有的类含有需要构造函数初始值的成员时.

---
>`BestPractise`:最好令构造函数初始值的顺序与成员声明的顺序保持一致.而且如果可能的话,尽量
避免使用某些成员初始化其他成员.

---

委托构造函数新特性
---
>`BestPractise`:在实际中,如果定义了其他构造函数,那么最好也提供一个默认构造函数.

静态数据成员定义在任何函数之外,一旦被定义,就将一直存在于程序的整个生命周期中.

>`BestPractise`:即使一个常量静态数据成员在类内部被初始化了,通常情况下也应该在类的外部定义
一下该成员.
