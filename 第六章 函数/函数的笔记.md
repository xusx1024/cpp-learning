# 函数
---

在C++语言中,名字有作用域,对象有生命周期,理解这两个概念非常重要.

局部静态对象:

在程序的执行路径第一次经过对象定义语句时初始化,并且直到程序终止才被销毁,在此期间即使对象所在
的函数结束执行也不会对它有影响.

java中没有静态的局部变量.

用处是?
作用域是局部的,生命周期是整个运行时的.
多次调用该方法,可以拿到上次的值.

---

函数声明

函数的名字也必须在使用之前声明.类似于变量,函数只能定义一次,但可以声明多次.

函数声明无须函数体,用一个分号替代即可.

因为无须函数体,所以也无须形参名字.尽管,写上形参的名字还是有用处的,可以帮助使用者更好地理解
函数的功能.

函数声明也称作函数原型.

建议变量,函数在头文件中声明,在源文件中定义.

>`BestPractice`:含有函数声明的头文件应该被包含到定义函数的源文件中.

形参初始化的机理与变量初始化一样.

如果形参是引用类型,它将绑定到对应的实参上;否则,将实参的值拷贝后赋给形参.java中也一样.

>`BestPractice`:熟悉C的程序员常常使用指针类型的形参访问函数外部的对象.在C++语言中,建议使
用引用类型的形参替代指针.

>`BestPractice`:如果函数无须改变引用形参的值,最好将其声明为常量引用.

---

数组的两个特性:
- 不允许拷贝 导致 无法以值传递的方式使用数组参数
- 使用数组时(通常)会将其转换成指针 导致 传递的参数时指向数组首元素的指针

```
void print(const int*)
void print(const int[])
void print(const int[10])
```
尽管表现形式不同,但上面的三个函数是等价的:每个函数的唯一形参都是const int*.
当编译器处理对print函数的调用时,只检查传入的参数是否是const int*.
注意,判断的是数组首元素的指针,所以:
```
int i=0,j[2] = {1,2};
print(&i);//正确:&i的类型是int*
print(j);//正确:j转换成int*并指向j[0]
```

```
// 正确:形参是数组的引用,维度是类型的一部分
void print(int (&arr)[10])
{
  for(auto elem : arr)
  {
    cout << elem << endl;
  }
}
```
&arr两端的括号必不可少:
int &arr[10]:arr被声明为引用的数组 (引用的数组)
int (&arr)[10]:具有10个整数的整型数组的引用 (数组的引用)

`*matrix`两端的括号必不可少

```
int *matrix[10] // 一个有10个指针的数组(指针的数组)
```

```
int (*matrix)[10] // 指向含有10个整数的数组的指针(数组的指针)
```

---

void函数中,可以没有return语句,这类函数的最后一句会隐式地执行return.

不要返回局部对象的引用或指针.
函数完成后,它所占用的存储空间也随之被释放.因此局部变量的引用将指向不再有效的内存区域.

要想确保返回值安全,问问自己:引用所引的是在函数之前已经存在的哪个对象?

---

慎用重载(effective java)

在C++语言中,名字查找发生在类型检查之前.

如果在内存作用域中声明名字,它将隐藏外层作用域中声明的同名实体.在不同的作用域中无法重载函数名.

---
默认实参:

调用含有默认实参的函数时,可以包含该实参,也可以省略该实参.

一旦某个形参被赋予默认值,它后面的所有形参都必须由默认值.

只能省略尾部的实参.

局部变量不能作为默认实参.

>`BestPractice`:通常,应该在函数生命中指定默认实参,并将该声明放在合适的头文件中.

---
内联函数,向编译器发起一个请求,函数在调用点展开,编译器可以选择忽略这个请求.

内联机制,用于优化规模较小,流程直接,频繁调用的函数.很多编译器都不支持内联递归函数.

---
constexpr函数,指能用于常量表达式的函数.

函数的返回类型及所有形参的类型都得是字面值类型,而且函数体中必须有且只有一条return语句.

执行初始化时,编译器把对constexpr函数的调用替换成其结果值.为了能在编译过程中随时展开,constexpr
函数被隐式地指定为内联函数.

---
assert是一种预处理宏.通常用于检查"不能发生"的条件.
```
assert(expr)
```
可以直接使用,不需要std::assert,也不需要提供using声明.

assert的行为依赖于NDEBUG的预处理变量的状态.如果定义了NDEBUG,则assert什么也不做.默认状态
下没有定义NDEBUG,assert将执行运行时检查.

>`BestPractice`:调用重载函数时应尽量避免强制类型转换.如果在实际应用中确实需要强制类型转换
,则说明我们设计的形参集合不合理.
